Distracted Driving Analysis
========================================================
author: Bryan Yu
date: August 5 2018
autosize: true

Committee: <br/> Dr. Derya Akleman, Dr. Samiran Sinha, Dr. Ergun Akleman

Experiment
========================================================

Controlled simulated driving experiment<sup>1</sup> to asses driving behavior]

Multiple different stressors for drives (cognitive, emotional, sensorimotor (texting) 

Sensors captured vehicle information and driver outputs

```{r, echo=FALSE, out.width="1400px", fig.align="center"}
knitr::include_graphics("https://media.nature.com/lw926/nature-assets/sdata/2017/sdata2017110/images_hires/sdata2017110-f1.jpg")
```

Objective
========================================================

Model volatility of lane positioning with regards to texting effect and population effects (age cohort)

```{r, echo=FALSE}
opts_chunk$set(cache=TRUE)
library(ggplot2)
library(gridExtra)
library(grid)
library(kableExtra)
library(dplyr)
library(here)
library(rstan)
library(foreach)
library(doParallel)

util <- new.env()
source(here::here('src', 'codebase', 'stan_utility.R'), local=util)
source(here("src", "codebase", "helper.R"))

c_light <- c("#DCBCBC")
c_light_highlight <- c("#C79999")
c_mid <- c("#B97C7C")
c_mid_highlight <- c("#A25050")
c_dark <- c("#8F2727")
c_dark_highlight <- c("#7C0000")

df_select <- feather::read_feather(here::here("study_df", "df_select.feather"))
subject_df <- feather::read_feather(here::here("study_df", "subject_df.feather"))
df <- df_select %>% 
    dplyr::filter(Distance >= 250) %>%         # Remove driver starts
    dplyr::filter(Distance <= 11000) %>%       # Remove driver ends
    dplyr::inner_join(subject_df, by=c("Subject"="subject"))

nd_raw <- df %>%  dplyr::filter(Drive == "ND") 
md_raw <- df %>%  dplyr::filter(Drive == "MD") 
rm(subject_df)

df_cleaner <- df %>% 
    dplyr::filter(!Subject %in% c(
        "T028", "T032", "T033", "T088")) %>%  # Missing stimulus variable
    dplyr::filter(!(Subject=="T002")) %>% # Missing eye gaze
    dplyr::filter(!(Subject=="T003" & Drive=="MD")) %>% 
    dplyr::filter(!(Subject=="T007")) %>% 
    dplyr::filter(!(Subject=="T008" & Drive=="MD")) %>% 
    dplyr::filter(!(Subject=="T015")) %>% 
    dplyr::filter(!(Subject=="T017")) %>% 
    dplyr::filter(!(Subject=="T023")) %>% 
    dplyr::filter(!(Subject=="T027")) %>% 
    dplyr::filter(!(Subject=="T028" & Drive=="MD")) %>% 
    dplyr::filter(!(Subject=="T029")) %>% 
    dplyr::filter(!(Subject=="T032")) %>% 
    dplyr::filter(!(Subject=="T036")) %>% 
    dplyr::filter(!(Subject=="T038")) %>% 
    dplyr::filter(!(Subject=="T042")) %>% 
    dplyr::filter(!(Subject=="T047")) %>% 
    dplyr::filter(!(Subject=="T055" & Drive=="ND")) %>% 
    dplyr::filter(!(Subject=="T086" & Drive=="ND")) %>%
    dplyr::filter(
        !dplyr::between(Distance, 5000, 7000)) %>% # Remove lane change
    dplyr::mutate(half=ifelse(Distance < 5000, 1, 2)) %>%
    dplyr::mutate(Stimulus=as.factor(Stimulus))
```

```{r plot, echo=FALSE, fig.align="center", fig.width=18, fig.height=8}
rect <- data.frame(xmin=5000, xmax=6750, ymin=-Inf, ymax=Inf)

nd_plot <- ggplot(nd_raw, aes(Distance, Lane.Position)) + 
    geom_rect(data=rect, aes(xmin=xmin, xmax=xmax, ymin=ymin, ymax=ymax),
              color="transparent", alpha=0.25, inherit.aes = FALSE) +
    geom_line(aes(colour=Subject)) + 
    theme_bw() + 
    theme(legend.position = "none") + 
    ggtitle("Normal Driving (ND)") +
    xlab("Distance (m)") + 
    ylab("Lane Position(m)") +
    coord_cartesian(ylim=c(-5.5, 7)) +
    annotate("text", x=5750, y=-4, 
             label="Removed\nLane Change", angle=90, color="Red", 
             size=4, hjust=0)

md_plot <- ggplot(md_raw, aes(Distance, Lane.Position)) +
    geom_rect(data=rect, aes(xmin=xmin, xmax=xmax, ymin=ymin, ymax=ymax),
              color="transparent", alpha=0.25, inherit.aes = FALSE) +
    geom_line(aes(colour=Subject)) + 
    xlab("Distance (m)") + ylab("Lane Position(m)") +
    theme_bw() + 
    theme(legend.position = "none") + 
    ylim(-5.5, 8) + 
    ggtitle("Texting Driving (MD)") +
    coord_cartesian(ylim=c(-5.5, 7)) +
    annotate("text", x=5750, y=-4, 
             label="Removed\nLane Change", angle=90, color="Red", 
             size=4, hjust=0)

grid.arrange(md_plot, nd_plot, ncol=2)
rm(nd_plot, md_plot, rect, nd_raw, md_raw)
```

```{r, echo=FALSE}
rm(df_select, df)

df_1 <- df_cleaner %>%  dplyr::filter(half==1) %>%
    dplyr::group_by(Subject, Drive) %>%
    dplyr::mutate(ntile=ntile(Distance, 200)) %>% # Bins for resampling
    dplyr::select(-half, -Time, -Lft.Pupil.Diameter, -Rt.Pupil.Diameter, 
                  -LaneOffset) %>% 
    dplyr::arrange(Subject, Drive, Distance) %>% 
    dplyr::group_by(Subject, Drive, ntile) %>%
    dplyr::mutate(mrank=dplyr::row_number()) %>% dplyr::filter(mrank==1) %>%
    dplyr::select(-mrank) %>%  dplyr::ungroup()

df_2 <- df_cleaner %>%  dplyr::filter(half==2) %>%
    dplyr::group_by(Subject, Drive) %>%
    dplyr::mutate(ntile=ntile(Distance, 190)) %>% # Bins for resampling
    dplyr::select(-half, -Time, -Lft.Pupil.Diameter, -Rt.Pupil.Diameter, 
                  -LaneOffset) %>% 
    dplyr::arrange(Subject, Drive, Distance) %>% 
    dplyr::group_by(Subject, Drive, ntile) %>%
    dplyr::mutate(mrank=dplyr::row_number()) %>% dplyr::filter(mrank==1) %>%
    dplyr::select(-mrank) %>%  dplyr::ungroup()

rm(df_cleaner)
```

* Each color is a separate driver (N=68)
* Data resampled at 390 data points (Prior to lane change: 200; After lane change: 190)
* Two models, one prior to lane change, one after
* Missing data filtered

Summary 
========================================================

**Assignment 2-3**: Linear regression on aggregated data set (per driver & drive, modelling standard deviation of lane positioning) and found divergence with model. The standard deviation of eye gaze and different population cohorts is inadequate to understanding the volatility of lane positioning. (Not included in this report to keep report concise)

**Assignment 4**: Focused this analysis on driver T001 with time-series AR(1) in the sensorimotor driving (MD) section with phase 1 and 2 with bayesian posterior distribution checks. I had some difficulties with using generative model on covariates in the time series model but believe I can solve this with more time.

**Assignment 5**: 

* Binned data to have equal sample sizes across all drivers 
* Fit AR(1) model on normal driving for `T021`. 
  * Model looks good but there are some prior samples with divergences, this is likely a minor issue for a simple model
  * AR(1) was shown not to be effective in the texting driving as expected
  
* Modelled ARCH(1) with texting driving but still working on generative ensemble

## Future Steps

1. Iterate on time series model with adding a stochastic volatilty model or heteroscedastic model (ARCH) with covariates

2. Inference for all drivers

3. Change-point model (account for driving phases)

Single driver (T021)
========================================================
```{r, echo=FALSE, fig.align="center", fig.height=6, fig.width=18}
rect_prior <- data.frame(xmin=0, xmax=5000, ymin=-Inf, ymax=Inf)
rect_post <- data.frame(xmin=7000, xmax=11000, ymin=-Inf, ymax=Inf)

subject <- "T021"
nd_single <- dplyr::bind_rows(df_1, df_2) %>% 
    dplyr::filter(Subject==subject & Drive=="ND")
md_single <- dplyr::bind_rows(df_1, df_2) %>% 
    dplyr::filter(Subject==subject & Drive=="MD")

nd_lane <- ggplot(nd_single, aes(Distance, Lane.Position)) +
    geom_rect(data=rect_prior, aes(xmin=xmin, xmax=xmax, ymin=ymin, ymax=ymax),
              color="transparent", alpha=0.5, inherit.aes = FALSE, 
              fill="palegreen1") +
    geom_rect(data=rect_post, aes(xmin=xmin, xmax=xmax, ymin=ymin, ymax=ymax),
              color="transparent", alpha=0.5, inherit.aes = FALSE, 
              fill="lightsalmon1") +
    geom_line() +
    geom_point(aes(colour=Stimulus), size=0.25) +
    theme_bw() + 
    theme(legend.position = "none") + 
    ggtitle("Normal Driving (ND)") +
    xlab("Distance (m)") + 
    ylab("Lane Position(m)") +
    coord_cartesian(ylim=c(1.5, 2.5)) +
    annotate("text", x=0, y=2.45, 
             label="First half", color="Black",  size=4, hjust=0) +
    annotate("text", x=7000, y=2.45, 
             label="Second half", color="Black",  size=4, hjust=0) +
    scale_color_hue(labels=c("None", "Texting"))

md_lane <- ggplot(md_single, aes(Distance, Lane.Position)) +
    geom_line() +
    geom_rect(data=rect_prior, aes(xmin=xmin, xmax=xmax, ymin=ymin, ymax=ymax),
              color="transparent", alpha=0.5, inherit.aes = FALSE, 
              fill="palegreen1") +
    geom_rect(data=rect_post, aes(xmin=xmin, xmax=xmax, ymin=ymin, ymax=ymax),
              color="transparent", alpha=0.5, inherit.aes = FALSE, 
              fill="lightsalmon1") +
    geom_point(aes(colour=Stimulus), size=0.25) +
    theme_bw() + 
    theme(legend.position = "none") + 
    ggtitle("Texting Driving (MD)") +
    xlab("Distance (m)") + 
    ylab("Lane Position(m)") +
    coord_cartesian(ylim=c(1.5, 2.5)) +
    annotate("text", x=0, y=2.45, 
             label="First half", color="Black",  size=4, hjust=0) +
    annotate("text", x=7000, y=2.45, 
             label="Second half", color="Black",  size=4, hjust=0) +
    scale_color_hue(labels=c("None", "Texting"))

grid_arrange_shared_legend(md_lane, nd_lane, ncol=2)
rm(nd_lane, md_lane)

md_eye <- ggplot(md_single, aes(Distance, Gaze.Y.Pos)) +
    geom_rect(data=rect_prior, aes(xmin=xmin, xmax=xmax, 
                                   ymin=ymin, ymax=ymax),
              color="transparent", alpha=0.5, inherit.aes = FALSE, 
              fill="palegreen1") +
    geom_rect(data=rect_post, aes(xmin=xmin, xmax=xmax,
                                  ymin=ymin, ymax=ymax),
              color="transparent", alpha=0.5, inherit.aes = FALSE, 
              fill="lightsalmon1") +
    geom_point(aes(colour=Stimulus), size=1) +
    theme_bw() + 
    theme(legend.position = "none") + 
    ggtitle("Texting Driving (ND)") +
    xlab("Distance (m)") + 
    ylab("Y Eye Gaze") +
    coord_cartesian(ylim=c(0, 1000)) +
    annotate("text", x=0, y=245, 
             label="First half", color="Black",  size=4, hjust=0) +
    annotate("text", x=7000, y=245, 
             label="Second half", color="Black",  size=4, hjust=0) +
    scale_color_hue(labels=c("None", "Texting"))

nd_eye <- ggplot(nd_single, aes(Distance, Gaze.Y.Pos)) +
    geom_rect(data=rect_prior, aes(xmin=xmin, xmax=xmax, ymin=ymin, ymax=ymax),
              color="transparent", alpha=0.5, inherit.aes = FALSE, 
              fill="palegreen1") +
    geom_rect(data=rect_post, aes(xmin=xmin, xmax=xmax, ymin=ymin, ymax=ymax),
              color="transparent", alpha=0.5, inherit.aes = FALSE,
              fill="lightsalmon1") +
    geom_point(aes(colour=Stimulus), size=1) +
    theme_bw() + 
    theme(legend.position = "none") + 
    ggtitle("Normal Driving (ND)") +
    xlab("Distance (m)") + 
    ylab("Y Eye Gaze") +
    annotate("text", x=0, y=245, 
             label="First half", color="Black",  size=4, hjust=0) +
    annotate("text", x=7000, y=245, 
             label="Second half", color="Black",  size=4, hjust=0) +
    coord_cartesian(ylim=c(0, 1000)) +
    scale_color_hue(labels=c("None", "Texting"))

grid_arrange_shared_legend(md_eye, nd_eye, ncol=2)
rm(subject, nd_eye, md_eye, nd_single, md_single)
```

**First half ACF analysis**

```{r, echo=FALSE, fig.align="center", fig.height=4, fig.width=18}
subject <- "T021"
conf.level <- 0.95
nd_half <- df_1 %>% dplyr::filter(Subject==subject & Drive=="ND")
md_half <- df_1 %>% dplyr::filter(Subject==subject & Drive=="MD")
acf_nd <- acf(nd_half$Lane.Position, plot=FALSE)
acf_md <- acf(md_half$Lane.Position, plot=FALSE)
acf_nd_df <- with(acf_nd, data.frame(lag, acf))
acf_md_df <- with(acf_md, data.frame(lag, acf))
ciline <- qnorm((1 - conf.level)/2)/sqrt(length(nd_half$Lane.Position))

nd_acf <- ggplot(acf_nd_df, aes(lag, acf)) +
    geom_segment(aes(xend=lag, yend=0)) +
    geom_hline(aes(yintercept=0)) + 
    geom_hline(aes(yintercept= -ciline), linetype=2, color='darkblue') +
    geom_hline(aes(yintercept= ciline), linetype=2, color='darkblue') +
    theme_bw() + 
    theme(legend.position = "none") + 
    ggtitle("Normal Driving (ND)") +
    xlab("Lag") + 
    ylab("ACF")
md_acf <- ggplot(acf_md_df, aes(lag, acf)) +
    geom_segment(aes(xend=lag, yend=0)) +
    geom_hline(aes(yintercept=0)) + 
    geom_hline(aes(yintercept= -ciline), linetype=2, color='darkblue') +
    geom_hline(aes(yintercept= ciline), linetype=2, color='darkblue') +
    theme_bw() + 
    theme(legend.position = "none") + 
    ggtitle("Texting Driving (MD)") +
    xlab("Lag") + 
    ylab("ACF")
grid.arrange(md_acf, nd_acf, ncol=2)
rm(subject, conf.level, acf_nd, acf_md, acf_nd_df, acf_md_df, ciline, md_acf, nd_acf, rect_post, rect_prior)

```

AR(1) of Normal Driving (ND)
========================================================

**Conceptual Analysis**

Single driver staying in the middle of a lane (3.65m wide). Should expect that as the driver moves out of the middle of lane to correct by reducing lane position back to middle (~1.825m). Would expect that mean and variance is constant.

**Summary Statistic**
Correlogram with posterior predictive check

**Generative Model (prior and likelihood)**
In order to stay stationary, $\rho$ should be below 1 and should be positive as the driver moves outside the middle of lane to regress back to the mean. Prior for $\rho$ should be below 1. Symmetric beta prior will be useful to to have a bounded (0, 1) distribution.

$$\rho \sim \textrm{Beta}(1.5, 1.5)$$

$$y_n \sim \mathcal{N}(\alpha + \rho_{n-1}, \sigma)$$

```{r 1.1.4a, echo=FALSE, fig.align="center", fig.width=12, fig.height=6}
rho <- seq(-.1, 1.1, 0.001)

plot(rho, dbeta(rho, 1.5, 1.5), type="l", col=c_dark_highlight, lwd=2,
     xlab=expression(rho), ylab="Prior Density", yaxt='n')

rho99 <- seq(-.1, 1, 0.001)
dens <- dbeta(rho99, 1.5, 1.5)
rho99 <- c(rho99, 1, 0)
dens <- c(dens, 0, 0)

polygon(rho99, dens, col=c_dark, border=NA)
rm(rho, rho99)
```

Prior predictive distribution
========================================================

```{r 1.1.5a, echo=FALSE, results="hide"}
R <- 1000
y <- nd_half$Lane.Position; N <- length(y);
simu_data <- list("N" = N)
fit <- stan(here("src", "stan", "gen_arK.stan"), 
            data=simu_data, iter=R, warmup=0, chains=1, refresh=R, seed=1000,
            algorithm="Fixed_param")
simu_rhos <- extract(fit)$rho
simu_ys <- extract(fit)$y
```

#### Analyze the prior predictive distribution
```{r 1.1.5b, echo=FALSE, fig.align="center", fig.height=6, fig.width=12}
B <- 24
counts <- sapply(1:R, function(r) acf(simu_ys[r,], plot=FALSE)$acf)
probs <- c(0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9)
cred <- sapply(1:B, function(b) quantile(counts[b, ], probs=probs))

idx <- rep(1:B, each=2)
x <- sapply(1:length(idx), function(b) if(b %% 2 == 0) idx[b] + 0.5 else idx[b] - 0.5)
pad_cred <- do.call(cbind, lapply(idx, function(n) cred[1:9, n]))

plot(1, type="n", main="Prior Predictive Correlogram",
     xlim=c(0.5, B + 0.5), xlab="y", ylim=c(0, max(cred[9,])), ylab="")
 
polygon(c(x, rev(x)), c(pad_cred[1,], rev(pad_cred[9,])),
        col = c_light, border = NA)
polygon(c(x, rev(x)), c(pad_cred[2,], rev(pad_cred[8,])),
        col = c_light_highlight, border = NA)
polygon(c(x, rev(x)), c(pad_cred[3,], rev(pad_cred[7,])),
        col = c_mid, border = NA)
polygon(c(x, rev(x)), c(pad_cred[4,], rev(pad_cred[6,])),
        col = c_mid_highlight, border = NA)
lines(x, pad_cred[5,], col=c_dark, lwd=2)

rm(B, counts, cred, idx, x, pad_cred)
```

```{r 1.1.5c, echo=FALSE, results="hide"}
tryCatch({
  registerDoParallel(makeCluster(detectCores()))
  simu_list <- t(data.matrix(data.frame(simu_rhos, simu_ys)))

  # Compile the posterior fit model
  fit_model = stan_model(file=here::here('src', 'stan', 'ar1.stan'))
  ensemble_output <- foreach(simu=simu_list, .combine='cbind') %dopar% {
    simu_rho <- simu[1]
    simu_y <- simu[2:(N + 1)];

    # Fit the simulated observation
    input_data <- list("N" = N, "y" = simu_y)

    capture.output(library(rstan))
    capture.output(fit <- sampling(fit_model, data=input_data, seed=4938483))

    # Compute diagnostics
    util <- new.env()
    source(here::here('src', 'codebase', 'stan_utility.R'), local=util)
    warning_code <- util$check_all_diagnostics(fit, quiet=TRUE)

    # Compute rank of prior draw with respect to thinned posterior draws
    sbc_rank_rho   <- sum(simu_rho < extract(fit)$rho[seq(1, 4000 - 8, 8)])

    # Compute posterior sensitivities
    s <- summary(fit, probs = c(), pars='rho')$summary
    post_mean_rho <- s[,1]
    post_sd_rho <- s[,3]
    prior_sd_rho <- sqrt(2*2 / ((2 + 2)^2 * (2 + 2 + 1))) # THIS!!!
    
    z_score_rho <- abs((post_mean_rho - simu_rho ) / post_sd_rho)
    shrinkage_rho <- 1 - (post_sd_rho / prior_sd_rho)**2
    
    c(warning_code, 
      sbc_rank_rho, z_score_rho, shrinkage_rho)
  }
}, finally={ stopImplicitCluster() })
```

```{r 1.1.5e, echo=FALSE, fig.align="center", fig.height=5, fig.width=16}
# rho
sbc_rank <- ensemble_output[2,]
sbc_hist <- hist(sbc_rank, seq(0, 500, 25) - 0.5, plot=FALSE)
par(mfrow=c(1, 2))
plot(sbc_hist, main="", xlab="Prior Rank (rho)", yaxt='n', ylab="")

low <- qbinom(0.005, R, 1 / 20)
mid <- qbinom(0.5, R, 1 / 20)
high <- qbinom(0.995, R, 1 / 20)
bar_x <- c(-10, 510, 500, 510, -10, 0, -10)
bar_y <- c(high, high, mid, low, low, mid, high)

polygon(bar_x, bar_y, col=c("#DDDDDD"), border=NA)
segments(x0=0, x1=500, y0=mid, y1=mid, col=c("#999999"), lwd=2)

plot(sbc_hist, col=c_dark, border=c_dark_highlight, add=T)
z_score <- ensemble_output[3,]
shrinkage <- ensemble_output[4,]

plot(shrinkage, z_score, col=c("#8F272720"), lwd=2, pch=16, cex=0.8,
     main="rho",
     xlim=c(0, 1), xlab="Posterior Shrinkage",
     ylim=c(0, 5), ylab="Posterior z-Score")
par(mfrow=c(1, 1))
```

* Simulation based calibration test: Close to uniform
* Posterior shrinkage shows highly informative observations (Close to 1)
* Posterior z-score shows that posterior recovers parameters (Most below 3)

Fitting actual observations
========================================================
```{r 1.1.6b, echo=FALSE, fig.align="center", results="hide"}
input_data <- list("y"= y, "N"=N)
fit <- stan(file=here('src', 'stan', 'ar1.stan'), data=input_data,
                      seed=493483, refresh=2000)
params <- extract(fit)
```

```{r, echo=FALSE, fig.align="center"}
knitr::kable(summary(fit, prob=c(.50), pars=c('rho', 'alpha', 'sigma'))$summary) %>% 
    kable_styling(bootstrap_options = c("striped", "hover"))
```

```{r 1.1.6a, fig.height=5, fig.width=12, results="hide", echo=FALSE, fig.align="center"}
par(mfrow=c(1, 3))
hist(params$alpha, main="", xlab="alpha", yaxt="n", ylab="",
     col=c_dark, border=c_dark_highlight)
hist(params$rho, main="", xlab="rho", yaxt="n", ylab="",
     col=c_dark, border=c_dark_highlight)
hist(params$sigma, main="", xlab="sigma", yaxt="n", ylab="",
     col=c_dark, border=c_dark_highlight)
par(mfrow=c(1, 1))
```

```{r 1.1.6c, cache=FALSE, echo=FALSE, fig.align="center", fig.width=12}
post <- as.matrix(fit)
sel <- grep("y_ppc", colnames(post))
# compute the credible intervals
ci50 <- matrix(NA, nrow = length(sel), ncol = 2)
ci90 <- matrix(NA, nrow = length(sel), ncol = 2)
for (i in 1:length(sel)) {
  ci50[i,] <- quantile(post[,sel[i]], prob = c(0.25, 0.75), names = FALSE)
  ci90[i,] <- quantile(post[,sel[i]], prob = c(0.05, 0.95), names = FALSE)
}

plot(0, type= "n", 
     xlim = c(0,length(input_data$y)), ylim = range(post[, sel]),
     xlab = "Distance", ylab = "Lane Position", main = "AR(1) Model - Normal Driving")
t <- 1:input_data$N
polygon(c(rev(t), t), c(rev(ci90[,1]), ci90[,2]), col = "#FF668830", border = FALSE)
polygon(c(rev(t), t), c(rev(ci50[,1]), ci50[,2]), col = "#FF668880", border = FALSE)

lines(1:input_data$N, colMeans(post[,sel]), col = "#40D2FE", lwd = 2)
# plot true series
lines(input_data$y, col = "#808080", lwd = 2)
legend("bottomright", c("actual", "pred (avg)", "pred (50% CI)", "pred (90% CI)"),
       col = c("#808080", "#40D2FE", "#FF668880", "#FF668830"),
       lwd = c(2,2,2), text.font=0.5)
```

Analyze the posterior predictive distribution (Normal drive)
========================================================

```{r 1.1.7a, echo=FALSE, fig.width=12, fig.align="center"}
B <- 23
obs_acf <- acf(input_data$y, plot=FALSE)$acf

idx <- rep(1:B, each=2)
x <- sapply(1:length(idx), function(b) if(b %% 2 == 0) idx[b] + 0.5 else idx[b] - 0.5)
pad_obs <- do.call(cbind, lapply(idx, function(n) obs_acf[n]))

counts <- sapply(1:4000, function(n) acf(params$y_ppc[n,], plot=FALSE)$acf)
probs <- c(0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9)
cred <- sapply(1:B, function(b) quantile(counts[b, ], probs=probs))
pad_cred <- do.call(cbind, lapply(idx, function(n) cred[1:9, n]))

plot(1, type="n", main="Posterior Predictive Correlogram",
     xlim=c(0.5, B + 0.5), xlab="Lag", ylim=c(0, max(cred[9,])), ylab="")
 
polygon(c(x, rev(x)), c(pad_cred[1,], rev(pad_cred[9,])),
        col = c_light, border = NA)
polygon(c(x, rev(x)), c(pad_cred[2,], rev(pad_cred[8,])),
        col = c_light_highlight, border = NA)
polygon(c(x, rev(x)), c(pad_cred[3,], rev(pad_cred[7,])),
        col = c_mid, border = NA)
polygon(c(x, rev(x)), c(pad_cred[4,], rev(pad_cred[6,])),
        col = c_mid_highlight, border = NA)
lines(x, pad_cred[5,], col=c_dark, lwd=2)

lines(x, pad_obs, col="white", lty=1, lw=2.5)
lines(x, pad_obs, col="black", lty=1, lw=2)
```

Still some weirdness in the first lags but fit captures the structure of data

AR(1) of Texting driving (MD)
========================================================
```{r 1.2.6b, echo=FALSE, fig.align="center", results="hide"}
input_data <- list("y"= md_half$Lane.Position, "N"=length(md_half$Lane.Position))
fit <- stan(file=here('src', 'stan', 'ar1.stan'), data=input_data, seed=493483, 
            refresh=2000)
params <- extract(fit)
```

```{r, echo=FALSE, fig.align="center",}
knitr::kable(summary(fit, prob=c(.50), pars=c('rho', 'alpha', 'sigma'))$summary) %>%
  kable_styling(bootstrap_options = c("striped", "hover"))
```

```{r 1.2.6a, fig.height=5, results="hide", echo=FALSE, fig.align="center"}
par(mfrow=c(1, 3))
hist(params$alpha, main="", xlab="alpha", yaxt="n", ylab="",
     col=c_dark, border=c_dark_highlight)
hist(params$rho, main="", xlab="rho", yaxt="n", ylab="",
     col=c_dark, border=c_dark_highlight)
hist(params$sigma, main="", xlab="sigma", yaxt="n", ylab="",
     col=c_dark, border=c_dark_highlight)
par(mfrow=c(1, 1))
```

```{r 1.2.6c, echo=FALSE, fig.align="center", fig.width=12}
post <- as.matrix(fit)
sel <- grep("y_ppc", colnames(post))
# compute the credible intervals
ci50 <- matrix(NA, nrow = length(sel), ncol = 2)
ci90 <- matrix(NA, nrow = length(sel), ncol = 2)
for (i in 1:length(sel)) {
  ci50[i,] <- quantile(post[,sel[i]], prob = c(0.25, 0.75), names = FALSE)
  ci90[i,] <- quantile(post[,sel[i]], prob = c(0.05, 0.95), names = FALSE)
}

plot(0, type= "n", 
     xlim = c(0,length(input_data$y)), ylim = range(post[, sel]),
     xlab = "Distance", ylab = "Lane Position", main = "AR(1) Model - Texting Driving")
t <- 1:input_data$N
polygon(c(rev(t), t), c(rev(ci90[,1]), ci90[,2]), col = "#FF668830", border = FALSE)
polygon(c(rev(t), t), c(rev(ci50[,1]), ci50[,2]), col = "#FF668880", border = FALSE)

lines(1:input_data$N, colMeans(post[,sel]), col = "#40D2FE", lwd = 2)
# plot true series
lines(input_data$y, col = "#808080", lwd = 2)
legend("bottomright", c("actual", "pred (avg)", "pred (50% CI)", "pred (90% CI)"),
       col = c("#808080", "#40D2FE", "#FF668880", "#FF668830"),
       lwd = c(2,2,2), text.font=0.5)
```

Analyze the posterior predictive distribution (Texting)
========================================================
```{r 1.2.7a, fig.align="center", fig.width=12, echo=FALSE}
B <- 23
obs_acf <- acf(input_data$y, plot=FALSE)$acf

idx <- rep(1:B, each=2)
x <- sapply(1:length(idx), function(b) if(b %% 2 == 0) idx[b] + 0.5 else idx[b] - 0.5)
pad_obs <- do.call(cbind, lapply(idx, function(n) obs_acf[n]))

counts <- sapply(1:4000, function(n) acf(params$y_ppc[n,], plot=FALSE)$acf)
probs <- c(0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9)
cred <- sapply(1:B, function(b) quantile(counts[b, ], probs=probs))
pad_cred <- do.call(cbind, lapply(idx, function(n) cred[1:9, n]))

plot(1, type="n", main="Posterior Predictive Correlogram",
     xlim=c(0.5, B + 0.5), xlab="Lag", ylim=c(0, max(cred[9,])), ylab="")
 
polygon(c(x, rev(x)), c(pad_cred[1,], rev(pad_cred[9,])),
        col = c_light, border = NA)
polygon(c(x, rev(x)), c(pad_cred[2,], rev(pad_cred[8,])),
        col = c_light_highlight, border = NA)
polygon(c(x, rev(x)), c(pad_cred[3,], rev(pad_cred[7,])),
        col = c_mid, border = NA)
polygon(c(x, rev(x)), c(pad_cred[4,], rev(pad_cred[6,])),
        col = c_mid_highlight, border = NA)
lines(x, pad_cred[5,], col=c_dark, lwd=2)

lines(x, pad_obs, col="white", lty=1, lw=2.5)
lines(x, pad_obs, col="black", lty=1, lw=2)
```

Not as great of a fit... as expected

ARCH(1) / GARCH(1, 1) of Texting driving (MD)
========================================================

*ARCH*
$$\sigma_t^2 = \alpha_0 + \alpha_{texting} + \alpha_1 a^2_{t-1}$$

*GARCH*
$$\sigma_t^2 = \alpha_0 + \alpha_{texting} + \alpha_1 a^2_{t-1} + \beta \sigma^2_{t-1}$$

Still in progress ... generative ensemble difficult with current priors